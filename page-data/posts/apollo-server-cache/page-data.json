{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/apollo-server-cache","result":{"data":{"markdownRemark":{"id":"01ff2e19-450a-583c-99ad-7c52410522c6","html":"<h2 id=\"intro\" style=\"position:relative;\"><a href=\"#intro\" aria-label=\"intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intro</h2>\n<p>Apollo 作為 graphql engine 提供了非常便利的 cache 機制，然而在 cahce 提供的便利性之外，卻也導致後續的 request 及 graphql 錯誤讀取 cache 中資料的可能性，產生資料無法正確更新的問題。本文將基於我最近的經驗與理解做基礎的介紹，並試圖釐清作為初學者所遇到的問題。</p>\n<p>作為一個新接觸 ApolloServer 的使用者，其中一個問題是該怎麼理解 apollo 所提供的 Cache。\n在初步讀完 document 之後，可以發現 apollo 在 ApolloServer 端提供 Cache (Redis, Memcached, etc.) 的同時，也在 ApolloClient 端提供了 <code class=\"language-text\">InMemoryCahce</code>，如何理解兩者與前端的互動就成為了第一個頭痛的點。</p>\n<h2 id=\"apolloclient--inmemorycache\" style=\"position:relative;\"><a href=\"#apolloclient--inmemorycache\" aria-label=\"apolloclient  inmemorycache permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ApolloClient &#x26; InMemoryCache</h2>\n<p><code class=\"language-text\">InMemoryCache</code> 既然是 Cache，那必然提供我們緩存資料的功能。沒錯，透過<code class=\"language-text\">InMemoryCache</code>，Clinet 端的可以透過 Cache 去紀錄使用者發送給 Server 的 GraphqQL query，並將query 與其回傳的資料緩存起來，當使用者再次發送同樣的 query 時， apollo 並不會實際送一個 request 到前端，而是從 Cahce 中去讀取資料。藉有減少發送請求的數量去加快在前端的反應速度。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token constant\">GET_MOVIE</span> <span class=\"token operator\">=</span> gql<span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">\n  mutation getMovie($id: Int!) {\n    getMovie(id: $id) {\n      name\n    }\n  }\n</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token constant\">UPDATE_MOVIE</span> <span class=\"token operator\">=</span> gql<span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">\n  mutation UpdateMovie($id: Int!, $name: String!) {\n    updateMovie(id: $id, name: $name) {\n      id\n      name\n    }\n  }\n</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><span></span></p>\n<p>這邊提一點，<code class=\"language-text\">InMemoryCache</code> 會透過發送 query 的 <code class=\"language-text\">__typename__</code>，以及 <code class=\"language-text\">id</code> 去生成一組 ID。因此當 Client 端發送上列的 Query 去拿取 ID 為 12 的 Movie 時 ，Cache 會為 Movie 生成一組 <code class=\"language-text\">Movie:12</code>，並在後續的 query 與這組 ID 有關時，透過其去查找Cache 中的資料。若發送的是 mutation，也能夠藉此更新存在 cache 中的資料。</p>\n<p>因此當我們分別發送上列的 query 與 mutation 時，apollo 會先從 server 中取得資料並存入 cache，而在進行 mutation 的時候，發送 request 到 server 端並用 <code class=\"language-text\">Movie:12</code> 去更新存在 Cache 中的資料，節省手動操作的麻煩。</p>\n<p>然而，上述的特性在某些特殊情形下會無法正確的更新的 Cache，這裡不多贅述，有興趣的朋友可以參照 <a href=\"https://github.com/apollographql/apollo-feature-requests/issues/4\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Umbrella ussue</a>。因為有這些特殊情形，apollo 也提供了 API 去操作 Cache，以下列出兩種我嘗試過的 API 給大家參考</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// update: modify cache with readQuery and writeQuery</span>\napollClient<span class=\"token punctuation\">.</span><span class=\"token function\">mutate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  mutation<span class=\"token operator\">:</span> <span class=\"token constant\">UPDATE_MOVIES</span><span class=\"token punctuation\">,</span>\n  variables<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    name\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function-variable function\">update</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">apollClient<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> data<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> addMovie <span class=\"token punctuation\">}</span> <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// Read the data from our cache for this query.</span>\n    <span class=\"token keyword\">const</span> data <span class=\"token operator\">=</span> apollClient<span class=\"token punctuation\">.</span><span class=\"token function\">readQuery</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> query<span class=\"token operator\">:</span> getMovies <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// Add our movie from the mutation to the end.</span>\n    data<span class=\"token punctuation\">.</span>movies<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>addMovie<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// Write our data back to the cache.</span>\n    apollClient<span class=\"token punctuation\">.</span><span class=\"token function\">writeQuery</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> query<span class=\"token operator\">:</span> getMovies<span class=\"token punctuation\">,</span> data <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// refetchQuery: query after mutation, passed an array of queries</span>\napollClient<span class=\"token punctuation\">.</span><span class=\"token function\">mutate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  mutation<span class=\"token operator\">:</span> <span class=\"token constant\">GET_MOVIES</span><span class=\"token punctuation\">,</span>\n  variables<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    name\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  refetchQuery<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token punctuation\">{</span>\n      query<span class=\"token operator\">:</span> <span class=\"token constant\">GET_MOVIES</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p><span></span></p>\n<p>這邊必須注意，<code class=\"language-text\">InMemoryCache</code> 顧名思義是 in memory，所以在前端 refresh 過後 <code class=\"language-text\">writeQuery</code> 修改的資料就會消失！</p>\n<p>最後，<code class=\"language-text\">InMemoryCache</code> 的設置方面十分容易，可以直接在 ApolloClinet 中建立</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> InMemoryCache<span class=\"token punctuation\">,</span> ApolloClient <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'@apollo/client'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> client <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ApolloClient</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...other arguments...</span>\n  cache<span class=\"token operator\">:</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">InMemoryCache</span><span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><span></span></p>\n<h2 id=\"apolloserver--http-cacheing\" style=\"position:relative;\"><a href=\"#apolloserver--http-cacheing\" aria-label=\"apolloserver  http cacheing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ApolloServer &#x26; HTTP cacheing</h2>\n<p>開門見山，在文擋的副標題有這麼一句: Automatically set HTTP cache headers and save full responses in a cache ，直截了當告訴你 ApolloServer 支援 HTTP 的 Cache Header，而究竟是怎麼個支持法，讓我們看下去。</p>\n<p>首先我們可以看到 ApolloServer 提供了以下的介面</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> server <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ApolloServer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  typeDefs<span class=\"token punctuation\">,</span>\n  resolvers<span class=\"token punctuation\">,</span>\n  cache<span class=\"token operator\">:</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MemcachedCache</span><span class=\"token punctuation\">(</span>\n    <span class=\"token punctuation\">[</span><span class=\"token string\">'memcached-server-1'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'memcached-server-2'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'memcached-server-3'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">{</span> retries<span class=\"token operator\">:</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> retry<span class=\"token operator\">:</span> <span class=\"token number\">10000</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// Options</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function-variable function\">dataSources</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    moviesAPI<span class=\"token operator\">:</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MoviesAPI</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">MoviesAPI</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">RESTDataSource</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">public</span> <span class=\"token function\">getMovie</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">id</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">/v1/movie/</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>id<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> cacheOptions<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> ttl<span class=\"token operator\">:</span> <span class=\"token number\">60</span> <span class=\"token punctuation\">}</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><span></span></p>\n<p>其中最大的關鍵在於 <code class=\"language-text\">cahceOptions</code>， <code class=\"language-text\">cahceOptions</code> 存在的目的是讓 HTTP request 能夠在 header 中加入 <code class=\"language-text\">Cache-Control</code>，進而做到 cache response 的效果。在此可以理解 ApolloServer 端的 cahce 是為 RestDataSource 而設計，使其能夠在給定的 ttl 有效期間內，讓從 server 端提取的資料不需要額外發送一個 request，可以從現存的 response 提取。</p>\n<p>雖然這很方便但也對我們的應用造成了下面這種情形：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1. query page (GET v1/movie/:id)\n2. mutation   (PATCH v1/movie/:id)\n3. refresh page (GET v1/movie/:id)</code></pre></div>\n<p><span></span></p>\n<p>按照步驟操作後，會發現在第三步重新整理過後，mutation 的結果並沒有成功地顯示在前端，儘管資料可能已經正確的存在DB當中了。</p>\n<p>同樣的為了避免這種情況，可以透過在 Server 去確認 request 並針對想要 invalidate 的 request 去做設計。例如在資料被修改過的情形下，把 GET 回傳的資料從 Cache 中刪除，例如可以透過 Context 以及 Id 去做操作。</p>\n<h2 id=\"automatic-persisted-queries\" style=\"position:relative;\"><a href=\"#automatic-persisted-queries\" aria-label=\"automatic persisted queries permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Automatic Persisted Queries</h2>\n<p>看完這部分之後，大家可能會發現還有一個類似 Cache 的東西（至少我覺得）叫做 Automatic Persisted Query，簡稱為APQ，APQ的結構如下圖：</p>\n<img src=\"https://www.apollographql.com/docs/apollo-server/98cb0f1ed777fbd3fb0d0701e41d5dee/persistedQueries.optPath.png\" class=\"mb-4\">\n<blockquote>\n<p>Photo Credit: Apollo Docs</p>\n</blockquote>\n<p>APQ 的存在主要是為了處理 GraphQL query 大小太大導致的延遲問題，其會將一個 query 包成 hash 傳送給介於 Apollo Server 及 Client 中間的 cache layer，並透過確認是否有hash key 來決定是否要發送完整的 graphql query 給 server，因此無論如何再 server 端都會執行 query，而其 cache 的並不是回傳的資料本身\b，而是從 client 端傳到 server端的 query body。</p>\n<h2 id=\"summary\" style=\"position:relative;\"><a href=\"#summary\" aria-label=\"summary permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Summary</h2>\n<p>Apollo cahce 的設計博大而精深，也在最新的 ApolloClient 3.0 中引進了不少新的操作，實在無法用一篇文章去解釋全部的操作與細節。總而言之，ApolloClient 的 <code class=\"language-text\">InMemoryCahce</code> 是為前端的 graphql 而設計，ApolloServer 端的是針對發送給不同 Data Service 的 response 做 cache。</p>\n<p>參考資料:</p>\n<ul>\n<li><a href=\"https://www.apollographql.com/blog/graphql-caching-the-elephant-in-the-room-11a3df0c23ad/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">graphql-caching-the-elephant-in-the-room</a></li>\n<li><a href=\"https://stackoverflow.com/questions/53358443/apollo-server-confusion-about-cache-datasource-options\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">RestDataResource cache vs InMemoryCache</a></li>\n<li><a href=\"https://www.apollographql.com/docs/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Apollo Docs</a></li>\n<li><a href=\"https://www.apollographql.com/docs/react/caching/cache-configuration/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">ApolloClinet cache confugration</a></li>\n<li><a href=\"https://www.apollographql.com/docs/apollo-server/performance/caching/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">ApolloServer cache confugration</a></li>\n</ul>","fields":{"slug":"/posts/apollo-server-cache","tagSlugs":["/tag/graphql/","/tag/apollo/"]},"frontmatter":{"date":"2020-09-24","description":"Apollo 作為 graphql engine 提供了非常便利的 cache 機制，然而在 cahce 提供的便利性之外，卻也導致後續的 request 及 graphql 錯誤讀取 cache 中資料的可能性，產生資料無法正確更新的問題。本文將基於我最近的經驗與理解做基礎的介紹，並試圖釐清作為初學者所遇到的問題。 ","tags":["graphql","apollo"],"title":"Apollo Cache 的操作與理解","socialImage":null}}},"pageContext":{"slug":"/posts/apollo-server-cache"}},"staticQueryHashes":["251939775","401334301","4017299803","825871152"]}